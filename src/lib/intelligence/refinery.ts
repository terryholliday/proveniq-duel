import * as diff from "diff";
import {
    Iteration,
    IntelligenceConfig,
    ModelProvider,
    AdjudicationResult
} from "./types";
import { GeminiProvider, LLMProvider, OpenAIProvider } from "./llm-providers";

const ARCHITECT_SYSTEM = `
You are an expert software architect. Write a complete, functional solution for the user's request. Focus on clean structure and readability.

CRITICAL OUTPUT RULES:
1) Output ONLY one single markdown code block fenced as \`\`\` (or appropriate language).
2) The code must be complete and runnable as-is.
3) Do not output diffs, explanations, or extra text outside the code block.
`;

const REVIEWER_SYSTEM = `
You are a Senior Code Optimizer. You have been given a codebase generated by a junior model.
Your job is to:
1) Analyze it for bugs, security issues, missing edge cases, and inefficiencies.
2) Rewrite the ENTIRE code with improvements applied.

CRITICAL OUTPUT RULES:
1) Output ONLY one single markdown code block fenced with \`\`\`.
2) Do not output diffs. Do not output commentary. Only the full runnable code.
3) If the code is already optimal and no further improvements are possible, start your response with "[CONVERGED]" followed by the code block.
`;

const ADJUDICATOR_SYSTEM = `
You are the Proof-of-Truth Adjudicator. Your task is to verify if the final generated code exactly matches the original intent and requirements of the user's prompt.

Original Prompt:
{{TASK}}

Return your analysis in this JSON format:
{
  "score": <0-100 parity score>,
  "meetsOriginalIntent": <boolean>,
  "analysis": "<short 1-2 sentence explanation>"
}
`;

export class Refinery {
    private config: Required<IntelligenceConfig>;
    private gemini: GeminiProvider;
    private openai: OpenAIProvider;

    constructor(config: IntelligenceConfig) {
        this.config = {
            geminiModel: config.geminiModel ?? "gemini-3-pro-preview",
            openaiModel: config.openaiModel ?? "gpt-4o",
            temperature: config.temperature ?? 0.2,
            maxIterations: config.maxIterations ?? 3,
        };
        this.gemini = new GeminiProvider(this.config.geminiModel, this.config.temperature);
        this.openai = new OpenAIProvider(this.config.openaiModel, this.config.temperature);
    }

    private extractCodeBlock(text: string): { code: string; isFenced: boolean } {
        const codeFenceRegex = /```[\w\-\+]*\s*([\s\S]*?)```/g;
        const matches = Array.from(text.matchAll(codeFenceRegex));

        if (matches.length === 0) {
            return { code: text.trim(), isFenced: false };
        }

        // Return the content of the last match
        const code = matches[matches.length - 1][1].trim();
        return { code, isFenced: true };
    }

    private generateDiff(oldCode: string, newCode: string): string {
        const patch = diff.createTwoFilesPatch("previous", "current", oldCode, newCode);
        return patch;
    }

    async adjudicate(task: string, finalCode: string): Promise<AdjudicationResult> {
        const systemInstruction = ADJUDICATOR_SYSTEM.replace("{{TASK}}", task);
        const userPayload = `Final Refined Code:\n\n${finalCode}\n`;

        const rawResponse = await this.gemini.call(systemInstruction, userPayload);
        try {
            const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
            throw new Error("Invalid adjudication format");
        } catch (error) {
            console.error("Adjudication failed to parse:", error);
            return {
                score: 0,
                meetsOriginalIntent: false,
                analysis: "Failed to parse adjudication report."
            };
        }
    }

    async refine(task: string, onUpdate?: (iteration: Iteration) => void): Promise<Iteration[]> {
        const iterations: Iteration[] = [];
        let currentCode = "";
        let lastCode = "";

        for (let i = 0; i < this.config.maxIterations; i++) {
            const providerType: ModelProvider = i % 2 === 0 ? "gemini" : "openai";
            const provider: LLMProvider = providerType === "gemini" ? this.gemini : this.openai;
            const modelName = providerType === "gemini" ? this.config.geminiModel : this.config.openaiModel;

            const systemInstruction = i === 0 ? ARCHITECT_SYSTEM : REVIEWER_SYSTEM;
            const userPayload = i === 0 ? `Request:\n${task}\n` : `Current Code:\n\n${currentCode}\n`;

            const rawResponse = await provider.call(systemInstruction, userPayload);
            const isConverged = rawResponse.toUpperCase().includes("[CONVERGED]");
            const { code, isFenced } = this.extractCodeBlock(rawResponse);

            const iteration: Iteration = {
                index: i,
                provider: providerType,
                model: modelName,
                timestamp: new Date().toISOString(),
                rawResponse,
                extractedCode: code,
                isFenced,
                isConverged,
                diffSummary: i > 0 ? this.generateDiff(lastCode, code) : undefined,
            };

            iterations.push(iteration);
            lastCode = currentCode;
            currentCode = code;

            if (onUpdate) {
                onUpdate(iteration);
            }

            if (isConverged) break;
        }

        return iterations;
    }
}
